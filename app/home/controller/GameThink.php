<?php
namespace app\home\controller;
use GatewayClient\Gateway;
use think\cache\driver\Memcache;
use think\Db;
use think\Log;

/**
 * 出牌算法
 */
class GameThink extends Base
{
    static $cid;
    static $mem;
    function _initialize()
    {
        parent::_initialize(); // TODO: Change the autogenerated stub
        if (input('?cid')) {
            self::$cid = open_secret(input('cid'));
        }
        vendor('gateway.gatewayclient.Gateway');
//        Gateway::$registerAddress = 'card.dcwen.top:1238';
    }

    //出牌算法
    function send_card()
    {
        $my_send_card = get_card(input('card_arr_id'));//当前出的牌
        if (empty($my_send_card)) {
            echo edd_error('您还没出牌呢!^_^');
            die;
        }
        self::$mem = new Memcache();

        $room_id = input('room_id');

        $game_times_one_round = 'game_times_one_round' . $room_id;
        $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . self::$cid;//当前玩家手牌
        $last_player_card = 'room' . $room_id . 'player_card';//上个玩家发出的牌
        $last_player_id = 'room' . $room_id . 'player_id';//上个玩家发出的牌
        $round_times_key = 'room_round' . $room_id;//场次

        $now_pin = 'room' . $room_id . 'first_order';//当前玩家的出牌顺序编号
        $gamePlayer = 'room' . $room_id . 'allplayer';//获取该房间所有玩家信息
        $inner = 'inner' . $room_id;

        $pass_times_key = 'room' . $room_id . 'pass_player';//过得次数

        $allCardInfo = self::$mem->get($cardArrIdKey);//该局所有的牌相关信息
        $first_card_id = $allCardInfo['first_card_id'];//该局首发牌(必须包含)


        $nowCard = $allCardInfo['card'];//我的当前手牌

        $room = get_home_info($room_id);//获取房间信息
        $roomType = $room['room_type'];//房间类型

        if (!self::$mem->has($game_times_one_round)) {
            self::$mem->set($game_times_one_round,1);
        }
        $game_times = self::$mem->get($game_times_one_round);//该局是否第一次出牌
        if ($game_times==1) {
            //首发牌
            if (empty(array_diff($my_send_card, $nowCard))) {
                //来自于手牌
                if (self::$mem->get($round_times_key)==1) {
                    //第一轮，不管是瞎子玩法,黑桃五，霸王桩都需要先出庄牌
                    if (in_array($first_card_id, $my_send_card)) {
                        $type = \Card::card_type($my_send_card)['type'];
                        if (!empty($type)) {
                            self::success_send_card($last_player_card, $my_send_card, $nowCard, $cardArrIdKey, $now_pin, $gamePlayer, $inner, $type, $game_times_one_round, $room_id,$first_card_id,$last_player_id,$allCardInfo);
                        }else{
                            echo edd_error('不能这样出牌喔^_^');
                        }
                    }else{
                        echo edd_error('请加上庄牌喔^_^');
                    }
                }else {
                    //第二轮
                    if ($roomType == 3||$roomType==1) {
                        //瞎子霸王庄或霸王庄,赢家任容易出牌
                        $type = \Card::card_type($my_send_card)['type'];
                        if (!empty($type)) {
                            self::success_send_card($last_player_card, $my_send_card, $nowCard, $cardArrIdKey, $now_pin, $gamePlayer, $inner, $type, $game_times_one_round, $room_id,$first_card_id,$last_player_id,$allCardInfo);
                        }else{
                            echo edd_error('不能这样出牌喔^_^');
                        }
                    } else{
                        //瞎子玩法随机玩法/黑桃五玩法,先出庄派
                        if (in_array($first_card_id, $my_send_card)) {
                            $type = \Card::card_type($my_send_card)['type'];
                            if (!empty($type)) {
                                self::success_send_card($last_player_card, $my_send_card, $nowCard, $cardArrIdKey, $now_pin, $gamePlayer, $inner, $type, $game_times_one_round, $room_id,$first_card_id,$last_player_id,$allCardInfo);
                            }else{
                                echo edd_error('不能这样出牌喔^_^');
                            }
                        }else{
                            echo edd_error('请加上庄牌喔^_^');
                        }
                    }
                }
            }else{
              echo  edd_error('您没有这张牌喔^_^');
            }
        }elseif($game_times>1){
            $is_pass = self::card_pass($room_id);//当前手中的牌是否打得起
            if ($is_pass['error']==0||self::$mem->get($pass_times_key)==3) {
                //当前玩家手上有可打的牌
                if (empty(array_diff($my_send_card, $nowCard))) {
                    if (self::$mem->get($pass_times_key)==3) {
                        //过了3次，可以任意出牌
                        $type = \Card::card_type($my_send_card)['type'];
                        if (!empty($type)) {
                            if ($type == 'A') {
                                //如果他出单排，需要判断，他的下家是否报单，如果报单，则必须出最大
                                self::sigle_card_send($room_id, $my_send_card, $nowCard);
                            }
                            self::success_send_card($last_player_card, $my_send_card, $nowCard, $cardArrIdKey, $now_pin, $gamePlayer, $inner, $type, $game_times_one_round, $room_id,$first_card_id,$last_player_id,$allCardInfo);
                        }else{
                            echo edd_error('不能这样出牌喔^_^');
                        }
                    }else{
                        //来自于手牌
                        $last_card = self::$mem->get($last_player_card);
                        $res = \Card::game_think($last_card, $my_send_card);
                        $type = \Card::card_type($my_send_card)['type'];
                        if ($res['error'] == 0) {
                            if ($type == 'A') {
                                //如果他出单排，需要判断，他的下家是否报单，如果报单，则必须出最大
                                self::sigle_card_send($room_id, $my_send_card, $nowCard);
                            }
                            self::success_send_card($last_player_card, $my_send_card, $nowCard, $cardArrIdKey, $now_pin, $gamePlayer, $inner, $type, $game_times_one_round, $room_id,$first_card_id,$last_player_id,$allCardInfo);
                        }else{
                            echo edd_error($res['msg']);
                        }
                    }
                }else{
                    echo  edd_error('您没有这张牌喔^_^');
                }
            }else{
                $map = [
                    'player_id'=>self::$cid,
                ];
                Gateway::sendToGroup($inner, send_client($map, 'pass_player'));
                $watch_dog = 'watch_dog' . $room_id;
                Gateway::sendToGroup($watch_dog, send_client($map, 'pass_player'));
                echo edd_error('打不起,自动过');
            }
        }
    }

    //如果他出单排，需要判断，他的下家是否报单，如果报单，则必须出最大
    function sigle_card_send($room_id,$my_send_card,$nowCard)
    {
        self::$mem = new Memcache();
        $now_pin = 'room' . $room_id . 'first_order';//当前玩家的出牌顺序编号
        $pin_player_order=self::$mem->get($now_pin);
        $next_order=self::player_order($pin_player_order);//下家顺序编号

        $round_info_key = 'round_info_key' . $room_id;//每轮个人信息记录
        $round_info = self::$mem->get($round_info_key);
        $next_player = $round_info[$next_order];//下家player_id
        $next_player_id = $next_player['player_id'];
        $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . $next_player_id;//当前玩家手牌
        $allCardInfo = self::$mem->get($cardArrIdKey);//该局所有的牌相关信息
        $nextNowCard = $allCardInfo['card'];//当前手牌
        if (count($nextNowCard) == 1) {
            //确认下家报单
            $maxCard=\Card::auto_card_think($nowCard, 'A', 1);//最大单排
            $maxCardNums=\Card::find_card($maxCard[0],'nums');
            $my_send_card=\Card::find_card_arr($my_send_card);
            $my_send_card_nums = $my_send_card[0]['nums'];
            if ($maxCardNums != $my_send_card_nums) {
                echo edd_error('当前为下家报单,单牌必须出最大喔^_^');
                die;
            }
        }

    }

    /**
     * 出牌之前首先判断是否有盖牌
     */
    function pass_pin_next()
    {
        self::$mem = new Memcache();

        $room_id = input('room_id');
        $game_times_one_round = 'game_times_one_round' . $room_id;
        $pass_times_key = 'room' . $room_id . 'pass_player';//过得次数
        if (!self::$mem->has($game_times_one_round)) {
            self::$mem->set($game_times_one_round,1);
        }
        if (self::$mem->get($game_times_one_round) != 1) {
            //不是第一次出牌
            if (self::$mem->get($pass_times_key) == 3) {
                //过了3次，自由发牌
                $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . self::$cid;//当前玩家手牌
                $allCardInfo = self::$mem->get($cardArrIdKey);//该局所有的牌相关信息
                $nowCard = $allCardInfo['card'];//我的当前手牌

                $autoCard=\Card::auto_card_think($nowCard, 'A', 1);//优先打单牌(没有炸蛋的情况)
                $autoCardKey = 'room' . $room_id . 'autoCard';

                self::$mem->set($autoCardKey,$autoCard);
                self::$mem->tag($room_id . 'tag', [$autoCardKey]);

                echo edd_success('ok');
            }else{
                $is_pass = self::card_pass($room_id);//当前手中的牌是否打得起
                if ($is_pass['error'] == 1) {
                    //没有可出的牌
                    $game_times_one_round = 'game_times_one_round' . $room_id;
                    $now_pin = 'room' . $room_id . 'first_order';//当前玩家的出牌顺序编号
                    $inner = 'inner' . $room_id;

                    //直接过下步
                    self::$mem->inc($game_times_one_round, 1);
                    //更新下个出牌玩家编号
                    $pin_player_order=self::$mem->get($now_pin);
                    $pin_player_order=self::player_order($pin_player_order);
                    self::$mem->set($now_pin, $pin_player_order);
                    self::$mem->tag($room_id . 'tag', [$now_pin]);
                    //向大家广播谁先出牌
                    $first_order = self::$mem->get($now_pin);
                    $map = [
                        'first_order'=>$first_order
                    ];
                    Gateway::sendToGroup($inner, send_client($map, 'pin_first'));
                    $watch_dog = 'watch_dog' . $room_id;
                    Gateway::sendToGroup($watch_dog, send_client($map, 'pin_first'));
                    $fxMap = [
                        'pic_type'=>'pass',
                        'who_pass_id'=>self::$cid
                    ];
                    Gateway::sendToGroup($inner, send_client($fxMap, 'show_pic'));
                    $watch_dog = 'watch_dog' . $room_id;
                    Gateway::sendToGroup($watch_dog, send_client($fxMap, 'show_pic'));
                    self::pass_times($room_id);//记录过的次数
                    echo edd_error('手上没有可出的牌');
                }else{
                    //有可以打出的牌，作为自动打出时的牌
                    $autoCard = $is_pass['maxArrCard'];
                    $autoCardKey = 'room' . $room_id . 'autoCard';
                    self::$mem->set($autoCardKey, $autoCard);
                    self::$mem->tag($room_id . 'tag', [$autoCardKey]);
                    echo edd_success('ok');
                }
            }
        }else{
            //首发牌，默认出庄牌
            $first_id = [];
            $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . self::$cid;//当前玩家手牌
            $allCardInfo = self::$mem->get($cardArrIdKey);//该局所有的牌相关信息
            $first_card_id = $allCardInfo['first_card_id'];//该局首发牌(必须包含)
            array_push($first_id, $first_card_id);
            $autoCardKey = 'room' . $room_id . 'autoCard';
            self::$mem->set($autoCardKey, $first_id);
            self::$mem->tag($room_id . 'tag', [$autoCardKey]);

            echo edd_success('ok');
        }
    }

    //提示出牌
    function tipCard()
    {
        $room_id = input('room_id');
        self::$mem = new Memcache();
        $game_times_one_round = 'game_times_one_round' . $room_id;
        if (self::$mem->get($game_times_one_round) == 1) {
            //首发牌
            $first_id = [];
            $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . self::$cid;//当前玩家手牌
            $allCardInfo = self::$mem->get($cardArrIdKey);//该局所有的牌相关信息
            $first_card_id = $allCardInfo['first_card_id'];//该局首发牌(必须包含)
            array_push($first_id, $first_card_id);

            $tip_card_id = [$first_id];
        }else{
            $pass_times_key = 'room' . $room_id . 'pass_player';//过得次数
            $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . self::$cid;//当前玩家手牌
            $last_player_card = 'room' . $room_id . 'player_card';//上个玩家发出的牌
            $last_card = self::$mem->get($last_player_card);
            $allCardInfo = self::$mem->get($cardArrIdKey);//该局玩家牌相关信息
            $nowCard = $allCardInfo['card'];//我的当前手牌
            $last_card_arr = \Card::card_type($last_card);
            $last_card_nums = $last_card_arr['nums'];

            if (self::$mem->get($pass_times_key) == 3) {
                //过了3次，自由发牌
                $last_card_type = 'A';
                $last_card_nums = 1;
                $last_card = [];
            }else{
                $last_card_type = $last_card_arr['type'];
            }

            if ($last_card_type != 'AAAA') {
                //上家没有出炸弹，主动判断该玩家手牌是否有炸弹
                $tip_card_id=\Card::auto_card_tip($nowCard, $last_card_type, $last_card_nums, [], $last_card);
                $zadanArrId = \Card::auto_card_tip($nowCard, 'AAAA', 1,[],$last_card);
                if (!empty($zadanArrId)&&empty($tip_card_id)) {
                    //只有炸弹可出,没有其他组合
                } elseif (!empty($zadanArrId) && !empty($tip_card_id)) {
                    //炸弹可出+其他组合
                    array_push($zadanArrId,$tip_card_id);
                }else{
                    //没有炸弹可出，只有其他组合可出
                    $zadanArrId = $tip_card_id;
                }
            }else{
                //上家出了炸弹
                $tip_card_id=\Card::auto_card_tip($nowCard, $last_card_type, $last_card_nums, [], $last_card);
                $zadanArrId = $tip_card_id;
            }

            //如果有炸弹，则炸弹排在前面
            $tip_card_id = $zadanArrId;
        }

        echo json_encode($tip_card_id);
    }

    /**
     * 判断当前玩家手上是否拥有该牌
     * @param $room_id,当前玩家的缓存名称
     * @return array,手上最大能出的牌
     */
    static function card_pass($room_id)
    {
        $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . self::$cid;//当前玩家手牌
        $last_player_card = 'room' . $room_id . 'player_card';//上个玩家发出的牌

        self::$mem = new Memcache();

        $last_card = self::$mem->get($last_player_card);
        $allCardInfo = self::$mem->get($cardArrIdKey);//该局玩家牌相关信息
        $nowCard = $allCardInfo['card'];//我的当前手牌
        $is_za_dan = \Card::auto_card_think($nowCard, 'AAAA', 1);
        if (!empty($is_za_dan)) {
            $map= \Card::game_think($last_card, $is_za_dan);
            $map['maxArrCard'] = $is_za_dan;
        }else{
            $last_card_arr = \Card::card_type($last_card);
            $last_card_nums = $last_card_arr['nums'];
            $last_card_type = $last_card_arr['type'];
            $my_max_card_arr=\Card::auto_card_think($nowCard, $last_card_type, $last_card_nums);

            if (!empty($my_max_card_arr)) {
                $map= \Card::game_think($last_card, $my_max_card_arr);
                $map['maxArrCard'] = $my_max_card_arr;
            }else{
                $map = [
                    'error' => 1,
                    'msg' => '手上没有可出的牌'
                ];
            }

        }
        return $map;
    }

    /**
     * 成功发牌后更新及其发布状态
     * @param $last_player_card,上一轮玩家的牌
     * @param $my_send_card,当前玩家发出的牌
     * @param $nowCard,当前玩家现有的牌
     * @param $cardArrIdKey,手牌
     * @param $now_pin,当前出牌玩家编号
     * @param $gamePlayer,所有玩家
     * @param $inner,房间号
     * @param $type,出牌类型
     * @param $game_times_one_round,该轮第几回合
     * @param $room_id,房间id`
     * @param $first_card_id,庄牌id
     * @param $last_player_id,上一轮玩家id
     */
    static function success_send_card($last_player_card,$my_send_card,$nowCard,$cardArrIdKey,$now_pin,$gamePlayer,$inner,$type,$game_times_one_round,$room_id,$first_card_id,$last_player_id,$allCardInfo)
    {
        self::$mem = new Memcache();

        if ($type == 'AAAA') {
            //如果出的是炸弹
            $my_send_card_arr=\Card::find_card_arr($my_send_card);
            self::add_bomb($room_id, self::$cid,array_sum(array_column($my_send_card_arr, 'nums')));//存入炸弹
        }

        //存入打牌记录
        self::card_log(self::$cid, $my_send_card, $room_id);

        $order_card_send = \Card::find_card_arr($my_send_card);
        $order_card_send = array_column($order_card_send, 'id');
        $map = [
            'cardType'=>$type,
            'sendCard'=>$order_card_send,
            'player_id'=>self::$cid,
            'first_card_id'=>$first_card_id
        ];

//        $client_id= Gateway::getClientIdByUid('in_client' . self::$cid);
        //广播发出的牌
        Gateway::sendToGroup($inner, send_client($map, 'send_card'));
        $watch_dog = 'watch_dog' . $room_id;
        Gateway::sendToGroup($watch_dog, send_client($map, 'send_card'));

        //上家发的牌存入
        self::$mem->set($last_player_card, $my_send_card);
        self::$mem->set($last_player_id, self::$cid);
        //更新当前手牌
        $nowCard = rm_card_arr($nowCard, $my_send_card);
        $allCardInfo['card'] = $nowCard;
        self::$mem->set($cardArrIdKey, $allCardInfo);

        //更新下个出牌玩家编号
        $pin_player_order=self::$mem->get($now_pin);
        $pin_player_order=self::player_order($pin_player_order);
        self::$mem->set($now_pin, $pin_player_order);

        //更新该群玩家信息
        $group_all_player = self::$mem->get($gamePlayer);
        $group_all_player[self::$cid]['card_nums'] = count($nowCard);
        self::$mem->set($gamePlayer, $group_all_player);

        $round_info_key = 'round_info_key' . $room_id;//每轮信息记录
        $roundInfo = self::$mem->get($round_info_key);
        //报单时间
        if (count($nowCard)==1) {
            $player_order = $group_all_player[self::$cid]['player_order'];

            $roundInfo[$player_order]['single_date'] = time();
            $roundInfo[$player_order]['is_single'] =1;

            self::$mem->set($round_info_key, $roundInfo);
            self::$mem->tag($room_id . 'tag', [$round_info_key]);

            $fxMap = [
                'pic_type'=>'sigle',
                'who_pass_id'=>self::$cid
            ];
            static::write_single_times($room_id);//记录报单次数
            Gateway::sendToGroup($inner, send_client($fxMap, 'show_pic'));
            $watch_dog = 'watch_dog' . $room_id;
            Gateway::sendToGroup($watch_dog, send_client($fxMap, 'show_pic'));
        }

        $map = [
            'self_card_nums_now' => count($nowCard),
            'player_id'=>self::$cid
        ];
        Gateway::sendToGroup($inner, send_client($map, 'change_card_nums'));//改变牌的张数
        $watch_dog = 'watch_dog' . $room_id;
        Gateway::sendToGroup($watch_dog, send_client($map, 'change_card_nums'));
        self::rm_pass_times($room_id);//清除过的次数

        if (count($nowCard) == 0) {

            $allPlayer = Gateway::getClientSessionsByGroup($inner);//获取该房间在线人的个人信息
            $winPlayerId = 'room' . $room_id . 'winPlayer';//赢家id
            $pressCard = 'pressCard' . $room_id;//压得牌


            self::$mem->set($winPlayerId, self::$cid);//本轮赢家id
            self::$mem->tag($room_id . 'tag', [$winPlayerId]);

            $game_times_one_round = 'game_times_one_round' . $room_id;
            self::$mem->rm($game_times_one_round);//新的一局初始化
            $newPlayerArr = [];
            foreach ($allPlayer as $k=>$v) {
                $newPlayerArr[$v['player_id']]['score'] = 0;
                $allPlayer[$k]['is_prepare'] = 'no';
                Gateway::updateSession($k, $allPlayer[$k]);//将该所有玩家初始化为未准备
            }
           //先算基础分
            $baseScorePlayer=self::think_score($room_id,self::$cid,$newPlayerArr);
            //炸弹分
            $bombScorePlayer=self::think_bomb($room_id, $newPlayerArr);
            //当局分数
            $score_info = self::think_all_score($newPlayerArr, $room_id, $baseScorePlayer, $bombScorePlayer);

            //更新每轮分数
            foreach ($roundInfo as $k=>$v){
                $roundInfo[$k]['score'] = $score_info[$v['player_id']]['score'];
                self::$mem->set($round_info_key, $roundInfo);
                self::$mem->tag($room_id . 'tag', [$round_info_key]);
            }

            //存入炸弹
            $bombKey = 'room_id' . $room_id.'bomb';
            $bombs=self::$mem->get($bombKey);

            //存入该房间的每轮数据
            $round_room_key = 'round_room' . $room_id;
            $save_round_room = [
                'round_edd'=>time(),
                'card_over_player_id'=>self::$cid,
            ];
            $round_room = self::$mem->get($round_room_key);
            $round_room = array_merge($round_room, $save_round_room);


            //记录没把牌打的日志
            $send_card_log_key = 'send_card_log' . $room_id;
            $send_card_log = self::$mem->get($send_card_log_key);

            //广播场次
            $round_times = 'room_round' . $room_id;
            $bombTimesKey = 'bombTimesKey'.$room_id;
            $bombTimes = self::$mem->get($bombTimesKey);//炸弹个数
            $round_times = self::$mem->get($round_times);

            //最终局
            $room = get_home_info($room_id);//获取房间信息
            $roomRound = $room['round_times'];//房间局数

            if (self::$mem->has('room_round' . $room_id)) {
                if (self::$mem->get('room_round'.$room_id ) ==$roomRound){
                    //该牌桌结束
                    $round_times = 'last_round';
                }
            }

            //每轮结束剩余牌，及其玩家顺序
            $gamePlayer = 'room' . $room_id . 'allplayer';
            $roomPlayerInfo = self::$mem->get($gamePlayer);
            foreach ($roomPlayerInfo as $k=>$v) {
                $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . $v['player_id'];//当前玩家手牌
                $cardArr = self::$mem->get($cardArrIdKey);
                $data[] = [
                    'card' => $cardArr['card'],
                    'player_order' => $v['player_order'],
                ];
                self::$mem->rm($cardArrIdKey);//删除每个人的当前手牌
            }
            Log::notice($data);
            $map = [
                'round_times'=>$round_times,
                'score_info' => my_sort($score_info, 'all_score', SORT_DESC),
                'boom_rank'=>pow(2,$bombTimes),//倍率
                'boom_times'=>$bombTimes,//炸弹个数
                'online_player'=>Gateway::getClientSessionsByGroup($inner),
                'pressCard'=>self::$mem->get($pressCard),
                'round_end_card'=>$data
            ];

            Gateway::sendToGroup($inner, send_client($map, 'round_end'));
            $watch_dog = 'watch_dog' . $room_id;
            Gateway::sendToGroup($watch_dog, send_client($map, 'round_end'));

            //存入炸弹
            if (!empty($bombs)) {
                Db::name('bomb')->insertAll($bombs);
            }
            Db::name('room_round')->insert($round_room);//存入每轮信息
            Db::name('player_log')->insertAll($send_card_log);//存入操作日志
            Db::name('round')->insertAll($roundInfo); //存入每轮个人信息

            self::$mem->clear($room_id . 'round');

            if ($round_times == 'last_round') {
                //最终局
                del_room($room_id);//删除房间
                self::$mem->clear($room_id . 'tag');//删除房间有关的所有缓存
            }

           echo edd_success('ok');
           die;
        }
        //向大家广播谁先出牌
        $first_order = self::$mem->get($now_pin);
        $map = [
            'first_order'=>$first_order
        ];
        Gateway::sendToGroup($inner, send_client($map, 'pin_first'));
        $watch_dog = 'watch_dog' . $room_id;
        Gateway::sendToGroup($watch_dog, send_client($map, 'pin_first'));

        self::$mem->inc($game_times_one_round, 1);
        self::$mem->tag($room_id . 'tag', [$game_times_one_round, $cardArrIdKey, $last_player_card, $now_pin, $gamePlayer,$last_player_id]);

        echo edd_success('ok');
    }

    //获取下个出牌玩家的编号
    static function player_order($now_order)
    {
        if ($now_order == 3) {
            return 0;
        }
        return ++$now_order;
    }

    /**
     * 如果3个人都过的话，那个人就随便打
     * @param $room_id
     */
    static function pass_times($room_id)
    {
        self::$mem = new Memcache();
        $pass_times_key = 'room' . $room_id . 'pass_player';

            if (self::$mem->has($pass_times_key)) {
                if (self::$mem->get($pass_times_key) < 3) {
                    self::$mem->inc($pass_times_key, 1);
                }
            }else{
                self::$mem->set($pass_times_key,1);
                self::$mem->tag($room_id . 'tag', [$pass_times_key]);
            }

        return self::$mem->get($pass_times_key);
    }

    /**
     * 清除过得次数
     * @param $room_id
     */
    static function rm_pass_times($room_id)
    {
        self::$mem = new Memcache();
        $pass_times_key = 'room' . $room_id . 'pass_player';

        if (self::$mem->has($pass_times_key)) {
            self::$mem->rm($pass_times_key);
        }
    }

    /**
     * 存入打牌日志
     * @param $player_id
     * @param $send_card_id
     * @param $room_id
     */
    static function card_log($player_id,$send_card_id,$room_id)
    {
        self::$mem = new Memcache();
        $send_card_log_key = 'send_card_log' . $room_id;
        $cardArr=\Card::find_card_arr($send_card_id);
        $cardArr=array_column($cardArr, 'card');
        $cardArr=implode(',', $cardArr);

        $card_log = [
            'log_content'=>$cardArr,
            'player_id'=>$player_id,
            'log_date'=>time(),
            'room_id'=>$room_id,
            'round_id'=>self::$mem->get('room_round' . $room_id)
        ];

        if (self::$mem->has($send_card_log_key)) {
            //存在
            $send_card_log=self::$mem->get($send_card_log_key);
            array_push($send_card_log, $card_log);
            self::$mem->set($send_card_log_key, $send_card_log);
        }else{
            $send_arr = [];
            array_push($send_arr, $card_log);
            self::$mem->set($send_card_log_key, $send_arr);
        }

        self::$mem->tag($room_id . 'round', [$send_card_log_key]);
    }
    /**
     * 记录报单次数
     * @param $room_id
     */
    static function write_single_times($room_id)
    {
        $round_single_times_key='round_single_times'.$room_id;//报单次数
        self::$mem = new Memcache();
        if (self::$mem->has($round_single_times_key)) {
            self::$mem->inc($round_single_times_key, 1);
        }else{
            self::$mem->set($round_single_times_key, 1);
        }

        self::$mem->tag($room_id . 'round', [$round_single_times_key]);
    }
    /**
     * 存入炸弹
     */
    static function add_bomb($room_id,$player_id,$nums)
    {
        self::$mem = new Memcache();
        $bombKey = 'room_id' . $room_id.'bomb';//炸弹详情
        $bombTimesKey = 'bombTimesKey'.$room_id;//炸弹倍数
        $bombLuKey = 'bomblu' . $room_id;
        $round_times = 'room_round' . $room_id;
        $roomInfo = get_home_info($room_id);
        $inner = 'inner' . $room_id;
        $map = [
            'bomb_date'=>time(),
            'round_id'=>self::$mem->get($round_times),
            'room_id'=>$room_id,
            'player_id'=>$player_id,
            'bomb_num'=>$nums
        ];
        //存入炸弹信息，及其炸弹个数
        if (self::$mem->has($bombKey)) {
            self::$mem->inc($bombTimesKey, 1);
            $bomb = self::$mem->get($bombKey);
            array_push($bomb, $map);
            self::$mem->set($bombKey,$bomb);
        }else{
            self::$mem->set($bombTimesKey, 1);
            $bombArr = [];
            array_push($bombArr, $map);
            self::$mem->set($bombKey,$bombArr);
        }

        $bombTimes = self::$mem->get($bombTimesKey);
        if ($roomInfo['double'] == 1) {
            //如果是双倍炸弹
            $bombsRank=pow(2, $bombTimes);//炸弹倍数

            $map = [
                'bombs' => $bombsRank
            ];
            self::$mem->set($bombLuKey, $bombsRank);//记录倍数
            //改变桌面炸弹倍数
            Gateway::sendToGroup($inner, send_client($map, 'change_bomb'));
            $watch_dog = 'watch_dog' . $room_id;
            Gateway::sendToGroup($watch_dog, send_client($map, 'change_bomb'));
        }
        self::$mem->tag($room_id . 'round', [$bombLuKey,$bombTimes,$bombKey,$bombTimesKey]);
    }
    /**
     * 计算炸弹
     */
    static function think_bomb($room_id,$newPlayerArr)
    {
        self::$mem = new Memcache();
        $bombKey = 'room_id' . $room_id.'bomb';//炸弹详情
        if (self::$mem->has($bombKey)) {
            $bomb = self::$mem->get($bombKey);
            $bombArr=my_sort($bomb, 'bomb_num', SORT_DESC);
            $bombMaxPlayerId = $bombArr[0]['player_id'];

            $bombPlayerArr = array_column($bomb, 'player_id');
            foreach ($newPlayerArr as $k=>$v){
                if (!in_array($k, $bombPlayerArr)) {
                    //没有炸弹的玩家
                    $newPlayerArr[$k]['score'] = -10;
                    $newPlayerArr[$bombMaxPlayerId]['score'] += 10;
                }
            }
        }
        return $newPlayerArr;
    }

    /**
     * 计算分数
     * @param $player_id
     * @param $room_id
     * @param $cardNums
     * @param $newPlayerArr
     */
    static function think_score($room_id,$win_player_id,$newPlayerArr)
    {
        self::$mem = new Memcache();
        $inner = 'inner' . $room_id;
        $round_info_key = 'round_info_key' . $room_id;//每轮信息记录
        $gamePlayer = 'room' . $room_id . 'allplayer';//获取该房间所有玩家信息
        $bombLuKey = 'bomblu' . $room_id;//炸弹倍数
        $roomInfo = get_home_info($room_id);
        $is_double = $roomInfo['double'];

        $round_info=self::$mem->get($round_info_key);
        $group_all_player = self::$mem->get($gamePlayer);//玩家信息
        $bombLu = self::$mem->get($bombLuKey);//炸弹倍数

        $round_single_times_key='round_single_times'.$room_id;//报单次数
        $round_single_times = self::$mem->get($round_single_times_key);

        if ($round_single_times == 3) {
            //3家报单
            foreach ($round_info as $k=>$v){
                if ($v['player_id'] == $win_player_id&&$v['is_single']==1) {
                    //赢家报单并说明真实报单只有两家
                    $round_single_times = 2;
                    break;
                }
            }
        }

        if ($round_single_times >= 3) {
            //除开赢家的保单数

            if ($round_single_times == 4) {
                foreach ($round_info as $k=>$v){
                    if ($v['player_id'] == $win_player_id) {
                        unset($round_info[$k]);
                    }
                }
            }

            $new_sigle_times = my_sort($round_info, 'single_date', SORT_DESC);//报单先后排序
            $maxSigle = $new_sigle_times[0];
            $player_id = $maxSigle['player_id'];//获取最晚报单的玩家id
            $score = 10 * $bombLu;
            $newPlayerArr[$player_id]['score'] = -$score;
        }else{
            foreach ($newPlayerArr as $k=>$v){
                $cardArrIdKey = 'room' . $room_id . 'player_card_arr' .$k;
                $allCardInfo = self::$mem->get($cardArrIdKey);
                $nowCard = $allCardInfo['card'];//我的当前手牌
                $player_order = $group_all_player[$k]['player_order'];
                if ($k != $win_player_id) {
                    //赢家基础分单独计算
                    if ($round_info[$player_order]['is_single'] == 1) {
                        //该玩家报单
                        $score = 0;
                    }else{
                        if(count($nowCard) == 10){
                            //如果是春天
                            $score = 10 * $bombLu * 2;
                        }else{
                            if ($is_double == 1) {
                                //如果翻倍
                                $score = count($nowCard) * $bombLu;
                            }else{
                                $score = count($nowCard) * 1;
                            }
                        }
                    }
                    $newPlayerArr[$k]['score'] = -$score;
                }
            }
        }
        $scoreColume = array_column($newPlayerArr, 'score');
        $newPlayerArr[$win_player_id]['score']=-array_sum($scoreColume);
        return $newPlayerArr;
    }

    /**
     * 总的游戏分数
     * @param $newPlayerArr
     * @param $room_id
     * @param $baseScorePlayer
     * @param $bombScorePlayer
     * @return array
     */
    static function think_all_score($newPlayerArr,$room_id,$baseScorePlayer,$bombScorePlayer)
    {
        self::$mem = new Memcache();
        $roundScore =[];
        foreach ($newPlayerArr as $k=>$v){
            $all_score_key = 'all_score_key' . $room_id . 'player_id' .$k;//总的分数
            $roundScore[$k]['name'] = get_player($k,'name');
            $roundScore[$k]['score'] = $baseScorePlayer[$k]['score'] + $bombScorePlayer[$k]['score'];
            if (self::$mem->has($all_score_key)) {
                $oldScore = self::$mem->get($all_score_key);
                self::$mem->set($all_score_key, $oldScore + $roundScore[$k]['score']);
            }else{
                self::$mem->set($all_score_key, $roundScore[$k]['score']);
            }
            self::$mem->tag($room_id . 'tag', [$all_score_key]);

            $roundScore[$k]['all_score'] = self::$mem->get($all_score_key);
        }

        return $roundScore;
    }

}

