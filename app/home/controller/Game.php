<?php
namespace app\home\controller;
use GatewayClient\Gateway;
use GatewayWorker\Lib\MMysql;
use think\cache\driver\Memcache;
use think\Db;
use think\Log;


/**
 * 游戏规则
 */
class Game extends Base
{
    static $cid;
    static $mem;
    function _initialize()
    {
        parent::_initialize(); // TODO: Change the autogenerated stub
        if (input('?cid')) {
            self::$cid = open_secret(input('cid'));
        }
        vendor('gateway.gatewayclient.Gateway');
//        Gateway::$registerAddress = 'card.dcwen.top:1238';
    }

    /**
     * @return \think\response\View
     */
    function page()
    {
        self::$mem = new Memcache();
        self::$mem->clear();
//        dump(set_secret(24));
//        dump(set_secret(25));
//        dump(set_secret(26));
//        dump(set_secret(27));
//        return view('page');
    }

    function ppage()
    {
        return view('prepare');
    }

    function demo()
    {

    }
    //开始游戏，由房主启动
    function start_game()
    {
        self::$mem = new Memcache();
        $room_id = input('room_id');
        $inner = "inner".$room_id;
        $allPlayer = Gateway::getClientSessionsByGroup($inner);//获取该房间在线人的个人信息
        $onlineNums = Gateway::getClientCountByGroup($inner);//获取当前房内人数
        if ($onlineNums ==4) {
                self::round_time($allPlayer, $room_id);
                echo edd_success('start_game');
        }else{
            echo edd_error('凑齐4个人再开吧！^_^');
        }
    }

    //进入房间
    function inner_room()
    {
        self::$mem = new Memcache();
        $room_id = input('room_id');
        $inner = "inner".$room_id;
        $allPlayer = Gateway::getClientSessionsByGroup($inner);//获取该房间在线人的个人信息
        $client_id = input('client_id');


        $room_all_people_key = 'room_all_people' . $room_id;//该房间所有玩家id
        $room_all_people_is = self::$mem->has($room_all_people_key);
        $room_all_people = self::$mem->get($room_all_people_key);


        if ($room_all_people_is&&in_array(self::$cid,$room_all_people)) {
            //如果是玩家，提醒当前玩家自动连接connet
            $map = [
                'ajax_type' => 'start_connect',
            ];
            echo edd_success($map);
        }else{
            //看客
            $watch_dog = 'watch_dog' . $room_id;
            Gateway::joinGroup($client_id,$watch_dog);
            Gateway::bindUid($client_id, 'watch_room' . self::$cid);

            $room_one_round = 'room_one_round' . $room_id;//已经开始游戏

            //游戏已经开始，再次进入游戏,进入先前牌局，否则，重新洗牌
            $f_order = 'room' . $room_id . 'first_order';//第一个出牌的人的编号
            $gamePlayer = 'room' . $room_id . 'allplayer';
            $last_player_card = 'room' . $room_id . 'player_card';//上个玩家发出的牌
            $last_player_id = 'room' . $room_id . 'player_id';//上个发牌玩家id
            $bombTimesKey = 'bombTimesKey'.$room_id;//炸弹个数

            $room = get_home_info($room_id);
            $room_owner = $room['room_owner'];

            if ($room_owner != self::$cid) {
                //创立者进自己房间不关联
                self::$mem->set('last_join_room'.self::$cid,$room);//玩家进入的上个房间
                self::$mem->set('room_relate'.self::$cid, $room_id);//将该玩家和当前房间绑定
                self::$mem->tag($room_id . 'tag', ['last_join_room'.self::$cid,'room_relate'.self::$cid]);//加入该房间标签
            }

            if (self::$mem->has($room_one_round)) {
                //已经开始游戏，显示当前所有玩家及其出牌的情况
                $map = [
                    'all_player_info'=>self::$mem->get($gamePlayer),
                    'first_order'=>self::$mem->get($f_order),
                    'last_player_card'=>self::$mem->get($last_player_card),
                    'last_player_id'=>self::$mem->get($last_player_id),
                    'round_times'=>self::$mem->get('room_round' . $room_id),
                    'bombs'=>pow(2,self::$mem->get($bombTimesKey)),
                    'prepare_player_info'=> Gateway::getClientSessionsByGroup($inner),//获取该房间在线人的个人信息
                    'ajax_type'=>'show_game_info'
                ];
                echo edd_success($map);
            }else{
                //游戏尚未开始，显示已经准备的玩家
                $map['all_ready_people'] = $allPlayer;
                $map['ajax_type'] = 'show_ready_player';
                echo edd_success($map);
            }
        }
    }
    //桌面连接/桌子内部连接
    function connect()
    {
        self::$mem = new Memcache();
        $type = input('type');//场景
        $client_id = input('client_id');

        if ( $type== 'outter') {
            //房间外
            if (self::$mem->has('room_relate' . self::$cid)) {
                //如果他之前进入过该房间
                $room_id = self::$mem->get('room_relate' . self::$cid);//获取房间id
                echo edd_success(self::$mem->get($room_id . 'room_info'));//返回退出的房间详情

                Gateway::joinGroup($client_id, 'outter' . $room_id);//进入外部房间
            }

            Gateway::bindUid($client_id, 'out_client' . self::$cid);//房间有人进入用

        } elseif ($type == 'inner') {
            $onlineNums = 'onlineNums';
            Gateway::joinGroup($client_id, $onlineNums);
            //后台统计在线人数
            $mapOnelin = [
                'online_nums' => Gateway::getClientCountByGroup($onlineNums),
            ];
            Gateway::sendToUid('admin', send_client($mapOnelin, 'change_online'));

            //点击准备后
            //if该房间人数<4个，将该玩家id绑定到该房间
            $inner_client = 'in_client' . self::$cid;
            //房间内
            $room_id=input('room_id');
            $inner = "inner".$room_id;
            //广播
            if (self::$mem->has($inner_client)) {
                $inner_client = self::$mem->get($inner_client);
                //关闭上一个同id的client_id,保证4G和wifi切换中只有一个client_id绑定player_id
                Gateway::closeClient($inner_client);
            }

            $onlineNums = Gateway::getClientCountByGroup($inner);//获取当前房内人数
            if ($onlineNums < 4) {

                $player = get_player_info(self::$cid);//获取玩家信息
                $room = get_home_info($room_id);//获取该房间信息

                Gateway::bindUid($client_id, 'in_client' . self::$cid);//房间有人进入用

                if (self::$mem->has('room' . $room_id . 'player_pre' . self::$cid)) {
                    //存在在线状态
                    $prepare_status = self::$mem->get('room' . $room_id . 'player_pre' . self::$cid);
                }else{
                    $prepare_status = 'no';
                }

                $player=array_merge($player,['is_prepare'=>$prepare_status] );

                $room_owner = $room['room_owner'];//房屋创建者

                self::$mem->set('in_client' . self::$cid, $client_id);//保存房内链接的$client_id
                self::$mem->set('in_client'.$client_id, self::$cid);//通过client_id获取player_id
                self::$mem->set('in_room_id'.$client_id,$room_id);//每个进入游戏的和该房间id绑定,为掉线的提醒


                Gateway::setSession($client_id, $player);//client_id存入信息
                Gateway::joinGroup($client_id, $inner);//创建内部房间组
                $onlineNums = Gateway::getClientCountByGroup($inner);//获取当前房内人数

                $watch_dog = 'watch_dog' . $room_id;
                Gateway::leaveGroup($client_id, $watch_dog);

                $mess = [
                    'room_id'=>$room_id,
                    'player_nums' => $onlineNums
                ];
                Gateway::sendToUid('out_client'.$room_owner,send_client($mess,'change_nums'));//向该房间外的该房间拥有者广播当前人数
                Gateway::sendToGroup($inner,send_client($player,'add_player'),[$client_id]);//add_player广播给其他玩家
                Gateway::sendToGroup($watch_dog,send_client($player,'add_player'));//add_player广播给看客

                Gateway::sendToGroup('outter' . $room_id, send_client($mess, 'change_nums'));//向房间之外的玩家广播


                //保持游戏状态
                self::keep_status($room_id,$inner,$player);
                self::save_ip($room_id, $player);//ip存储

                $others = Gateway::getClientSessionsByGroup($inner);//获取该房间在线人的个人信息
                foreach ($others as $k=>$v){
                    if(!Gateway::isOnline($k)||$v['player_id'] == self::$cid){
                        unset($others[$k]);
                    }
                }
                //在线人的信息，自己的信息
                $map = [
                    'others' => $others,
                    'self' => $player,
                    'type' => 'first_connect',

                ];

                Gateway::sendToGroup($inner, send_client($map, 'pin_first'));
                echo edd_success($map);//ajax传给连接方的信息
            }else{
                echo edd_error('房间已经满啦!换一桌吧!^_^');
            }
        }
    }

    //保持回合状态
    static function keep_status($room_id,$inner,$player)
    {
        self::$mem = new Memcache();
        //游戏已经开始，再次进入游戏,进入先前牌局，否则，重新洗牌
        $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . self::$cid;
        $f_order = 'room' . $room_id . 'first_order';//第一个出牌的人的编号
        $gamePlayer = 'room' . $room_id . 'allplayer';
        $last_player_card = 'room' . $room_id . 'player_card';//上个玩家发出的牌
        $last_player_id = 'room' . $room_id . 'player_id';//上个发牌玩家id
        $zhuang_card = 'room' . $room_id . 'zhuang_card';
        $bombTimesKey = 'bombTimesKey'.$room_id;//炸弹个数


        if (self::$mem->has($cardArrIdKey)) {
            $map = [
                'all_player_info'=>self::$mem->get($gamePlayer),
                'my_card_now'=>self::$mem->get($cardArrIdKey),
                'first_order'=>self::$mem->get($f_order),
                'last_player_card'=>self::$mem->get($last_player_card),
                'last_player_id'=>self::$mem->get($last_player_id),
                'zhuang_card'=>self::$mem->get($zhuang_card),
                'self_id'=>self::$cid,
                'type'=>'turn_back',
                'round_times'=>self::$mem->get('room_round' . $room_id),
                'bombs'=>pow(2,self::$mem->get($bombTimesKey))
            ];

            $others = Gateway::getClientSessionsByGroup($inner);//获取该房间在线人的个人信息
            foreach ($others as $k=>$v){
                if(!Gateway::isOnline($k)||$v['player_id'] == self::$cid){
                    unset($others[$k]);
                }
            }
            //再次进入时，主动请求
            $first_order = self::$mem->get($f_order);
            $f_order_map = [
                'first_order'=>$first_order
            ];

            Gateway::sendToGroup($inner, send_client($f_order_map, 'pin_first'));

            //在线人的信息，自己的信息
            $map['others']=$others;
            $map['self']=$player;
            echo edd_success($map);
            die;
        }
    }

    //游戏准备
    static function prepare()
    {
        self::$mem = new Memcache();
        $room_id = input('room_id');
        $inner = "inner".$room_id;
        $watch_dog = 'watch_dog' . $room_id;//看客

            self::$mem->set('room' . $room_id . 'player_pre' . self::$cid, 'yes');

            $player = get_player_info(self::$cid);//获取玩家信息
            $player=array_merge($player,['is_prepare'=>'yes']);
            $client_id = Gateway::getClientIdByUid('in_client' . self::$cid);
            foreach ($client_id as $v){
                Gateway::updateSession($v, $player);
            }

            self::save_ip($room_id, $player);//ip存储

            $allPlayer = Gateway::getClientSessionsByGroup($inner);//获取该房间在线人的个人信息
            $start_flag = false;
            if (count($allPlayer) == 4) {
                //准备人数4个
                $start_flag = true;
                foreach ($allPlayer as $k=>$v){
                    if ($v['is_prepare'] == 'no') {
                        //如果有一个没准备好
                        $start_flag =false;
                        break;
                    }
                }
            }

            $map = [
                'cid'=>self::$cid
            ];

            Gateway::sendToGroup($inner, send_client($map, 'ready_player'),$client_id);
            Gateway::sendToGroup($watch_dog, send_client($map, 'ready_player'),$client_id);

            if ($start_flag) {
                self::round_time($allPlayer, $room_id);
            }
            echo edd_success('ok');
    }

    //每轮首发
    static function round_time($allPlayer,$room_id)
    {
        self::$mem = new Memcache();
        $round_times_key = 'room_round' . $room_id;//场次
        $pressCard = 'pressCard' . $room_id;
        //开始游戏标志
        $room_one_round = 'room_one_round' . $room_id;
        $watch_dog = 'watch_dog' . $room_id;//看客

        self::$mem->set($room_one_round, 'ok');
        self::$mem->set($room_id . 'tag',[$room_one_round]);

        //局数轮训
        if (self::$mem->has($round_times_key)) {
            self::$mem->inc($round_times_key, 1);
            self::$mem->tag($room_id . 'tag', [$round_times_key]);
        }else{
            self::$mem->set($round_times_key,1);
        }

        //同ip报警
        self::is_same_ip($allPlayer,$room_id);
        $room = get_home_info($room_id);//获取房间信息
        $roomType = $room['room_type'];//房间类型
        $roomCode = $room['room_code'];//房间号

        $inner = "inner".$room_id;
        $randCardNums = rand(0, 39);

        //是否压牌
        if ($roomType == 2 || $roomType == 3) {
            //瞎子算法摸牌
            $press = 1;
        }else{
            $press = 0;
        }

        $cards = \Card::wash_card($press);
        //如果瞎子玩法
        $randCardId = $cards['all_card'][$randCardNums]['id'];//随机抽一张牌
        $cardPress = $press==1?$cards['press_card']:'';
        $cardPressMem = self::$mem->set($pressCard, $cardPress);//压的牌

        $i = 0;
        $roomPlayerInfo = [];
        $roundInfo = [];
        $first_card_id = '';//首发玩家第一次需要出的牌,必须包含指定的某张牌
        $allPlayerId = array_column($allPlayer, 'player_id');//
        //某房间每轮的情况
        $round_room_key = 'round_room' . $room_id;
        $room_all_people = 'room_all_people' . $room_id;//该房间所有玩家id
        $round_room = [
            'room_id' => $room_id,
            'round_id' =>self::$mem->get($round_times_key),
            'round_start'=>time(),
            'press_card'=>json_encode($cardPress),
            'all_player'=>json_encode($allPlayerId)
        ];
        self::$mem->set($round_room_key, $round_room);
        self::$mem->set($room_all_people, $allPlayerId);

        self::$mem->tag($room_id . 'round', [$round_room_key,$pressCard]);

        foreach ($allPlayer as $k=>$v){
            //房间玩家信息
            $roomPlayerInfo[$v['player_id']] = [
                'player_id'=>$v['player_id'],
                'player_order'=>$i,
                'player_diamond'=>$v['diamond'],
                'player_name' => $v['name'],
                'player_avatar'=>$v['avatar'],
                'card_nums'=>10,
                'round_score'=>all_score($room_id,$v['player_id']),
            ];
            $player_order = 'room' . $room_id . 'order' . $i;
            self::$mem->set($player_order, $v['player_id']);//玩家顺序和玩家id关联

            $cardArrId = array_column($cards['new_card'][$i],'id');//获取每组牌的id

            //每轮信息记录
            $roundInfo[$i] = [
                'round_id'=>self::$mem->get($round_times_key),
                'player_id'=>$v['player_id'],
                'room_id'=>$room_id,
                'cards' => json_encode($cardArrId),
                'score'=>0,//最后积分
                'is_chuntian'=>0,//是否是春天
                'is_single'=>0,//是否报单
                'single_date'=>''//报单时间
            ];

            //0黑桃5上庄
            $map = [
                'card'=>$cardArrId
            ];
            /**
             * 第一个出牌的人算法
             */
            //第一局
            if (self::$mem->get('room_round'.$room_id)==1) {
                if ($press==1) {
                    //瞎子玩法
                    if (in_array($randCardId, $cardArrId)) {
                        $first_card_id = $randCardId;
                        $first_order = $i;//首先出牌的那个玩家顺序编号
                    }
                }else{
                    //黑桃5上庄或者霸王庄,第一轮黑桃5出牌
                    if(in_array('9', $cardArrId)) {
                        $first_card_id = 9;
                        $first_order = $i;//首先出牌的那个玩家顺序编号
                    }
                }
            }else{
                //第一局以后,
                if ($roomType == 3||$roomType==1) {
                    //瞎子霸王庄或霸王庄,赢家出牌
                    $first_card_id = 'all';
                    $winPlayerId = 'room' . $room_id . 'winPlayer';
                    $winPlayer =self::$mem->get($winPlayerId) ;//赢家编号
                    if ($winPlayer == $v['player_id']) {
                        $first_order = $i;//首先出牌的那个玩家顺序编号
                    }
                } elseif ($roomType == 2) {
                    //瞎子随机
                    if (in_array($randCardId, $cardArrId)) {
                        $first_card_id = $randCardId;
                        $first_order = $i;//首先出牌的那个玩家顺序编号
                    }
                }else{
                    //黑桃五上庄
                    if (in_array('9', $cardArrId)) {
                        $first_card_id = 9;
                        $first_order = $i;//首先出牌的那个玩家顺序编号
                    }
                }
            }
            $map = array_merge($map, ['first_card_id' => $first_card_id]);

            $cardArrIdKey = 'room' . $room_id . 'player_card_arr' . $v['player_id'];//在该局游戏的牌

            $in_one_home_player_id = 'in_one_home' . $v['player_id'];//记录当前进入的房间,用于阻止再次创建或者进入其他房间
            self::$mem->set($in_one_home_player_id,$roomCode);
            self::$mem->set($cardArrIdKey, $map);//每个人在本房间本局的牌
            //分别给各玩家发牌
            Gateway::sendToClient($k,send_client($map,'start_game'));

            self::$mem->tag($room_id . 'tag', [$cardArrIdKey,$in_one_home_player_id]);
            $i++;
        }

        $gamePlayer = 'room' . $room_id . 'allplayer';
        $last_player_card = 'room' . $room_id . 'player_card';//上个玩家发出的牌
        $last_player_id = 'room' . $room_id . 'player_id';//上个玩家发出的牌
        $zhuang_card = 'room' . $room_id . 'zhuang_card';//庄牌
        $round_info_key = 'round_info_key' . $room_id;//每轮个人信息记录
        $bombTimesKey = 'bombTimesKey'.$room_id;//炸弹个数
        $bombLuKey = 'bomblu' . $room_id;//炸弹倍数，计算用

        self::$mem->set($gamePlayer, $roomPlayerInfo);
        self::$mem->set($last_player_card, '');
        self::$mem->set($last_player_id, '');
        self::$mem->set($zhuang_card, $first_card_id);
        self::$mem->set($round_info_key, $roundInfo);
        self::$mem->set($bombTimesKey,0);
        self::$mem->set($bombLuKey,1);

        self::$mem->tag($room_id . 'tag', [$gamePlayer,$last_player_card,$last_player_id,$zhuang_card,$cardPressMem,$round_info_key,$room_all_people]);
        if (isset($first_order)) {
            $map = [
                'first_order'=>$first_order
            ];
            $f_order = 'room' . $room_id . 'first_order';//第一个出牌的人的编号
            self::$mem->set($f_order, $first_order);
            self::$mem->tag($room_id . 'tag' , [$f_order]);
            Gateway::sendToGroup($inner, send_client($map, 'pin_first'));//向大家广播谁先出牌
            Gateway::sendToGroup($watch_dog, send_client($map, 'pin_first'));

            $watch_map = [
                'all_player_info'=>self::$mem->get($gamePlayer),
                'first_order'=>self::$mem->get($f_order),
                'last_player_card'=>self::$mem->get($last_player_card),
                'last_player_id'=>self::$mem->get($last_player_id),
                'round_times'=>self::$mem->get('room_round' . $room_id),
                'bombs'=>pow(2,self::$mem->get($bombTimesKey)),
            ];

            Gateway::sendToGroup($watch_dog, send_client($watch_map, 'watch_start_game'));
        }

        $map = [
            'round_times'=>self::$mem->get($round_times_key)
        ];
        Gateway::sendToGroup($inner, send_client($map, 'change_round'));//发送轮数
        Gateway::sendToGroup($watch_dog, send_client($map, 'change_round'));

        $map = [
            'bombs' => pow(2,self::$mem->get($bombTimesKey))
        ];
        Gateway::sendToGroup($inner, send_client($map, 'change_bomb'));//炸弹倍数
        Gateway::sendToGroup($watch_dog, send_client($map, 'change_bomb'));

        Gateway::sendToGroup($inner, send_client($roomPlayerInfo, 'show_player'));//向大家广播目前所有玩家信息
        Gateway::sendToGroup($watch_dog, send_client($roomPlayerInfo, 'show_player'));
    }

      //ip存储
    static function save_ip($room_id,$player)
    {
        self::$mem = new Memcache();
        $roomUserIdIp = "room_ip" . $room_id . "@" . $player['name'];
        $ip = request()->ip();
        self::$mem->set($roomUserIdIp, $ip);
        self::$mem->tag($room_id . 'round', [$roomUserIdIp]);
    }

    //同ip报警
    static function is_same_ip($allPlayer,$room_id)
    {
        $arr = [];
        self::$mem = new Memcache();
        foreach ($allPlayer as $k => $v) {
            $roomUserIdIp = "room_ip" . $room_id . "@" . $v['name'];
            $ip = self::$mem->get($roomUserIdIp);
            if (empty($arr[$ip])) {
                $arr[$ip] = [$v['name']];
            } else {
                array_push($arr[$ip], $v['name']);
            }
        }

        $save_ip_name = "";
        foreach ($arr as $k => $v) {
            if (count($v) >= 2) {
                $save_ip_name .= "【" . implode(",", $v) . "】";
            }
        }

        $inner = "inner" . $room_id;
        if (!empty($save_ip_name)) {
            $map = [
                'msg' => $save_ip_name . '在同一个ip下>_<',
            ];
            Gateway::sendToGroup($inner, send_client($map, 'show_same_ip'));
        }
    }
}
